\documentclass[a4paper,12pt]{report}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{url}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{titlesec}
\usepackage{cite}

% Page Geometry
\geometry{a4paper,left=25mm,right=25mm,top=30mm,bottom=30mm}

% Chapter Title Formatting
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries\centering}
  {\chaptertitlename\ \thechapter}{20pt}{\Huge}

% Code Snippet Configuration
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

% --- Title Page ---
\thispagestyle{empty}
\begin{center}
  \Huge{\textsc{Design and Implementation of a Memory Management Unit and Cache Controller in RTL}}
\end{center}
%\vspace{0.5cm}
\begin{center}
  \large{(Monsoon 2025)}
\end{center}
\vspace{0.5cm}
\begin{center}
  \large{Submitted by}
\end{center}
\vspace{0.25cm}
\begin{center}
  \large{Kalrav Mathur (2210110338)}\\
  \vspace{0.25cm}
  \large{Akhil Sriram (2210110134)}
\end{center}
 \vspace{0.25cm}
\begin{center}
  \large{Under Supervision\\ of}
\end{center}
\begin{center}
  \large{Dr. Venkatnarayan Hariharan}\\
  \large{Department of Electrical Engineering}\\
\end{center}
\vspace{0.75cm}
\begin{figure}[htbp]
    \centering
    % Placeholder for logo - ensure logo.jpg exists
    % \includegraphics[width=4in]{logo.jpg}
\end{figure}
\pagebreak

% --- Abstract ---
\begin{center}
\huge{\textsc{Abstract}}
\end{center}
This project presents the complete Register Transfer Level (RTL) design, implementation, and verification of a memory management subsystem, comprising a Translation Lookaside Buffer (TLB)-based Memory Management Unit (MMU) and a 2-Way Set-Associative Cache Controller. The system is engineered to address the "memory wall" bottleneck by providing high-speed virtual-to-physical address translation and efficient data caching. The design is implemented in Verilog-2001, emphasizing modularity to support future multi-level hierarchies. Key contributions include a robust Finite State Machine (FSM) for cache control, an invalidation-based coherence mechanism for Write-Through policies, and a novel script-driven verification environment. This environment parses human-readable instruction files (e.g., \texttt{R 0x1000}) to drive simulation scenarios, bridging the gap between architectural intent and RTL verification. Extensive simulations validate the correctness of the LRU replacement policy, hit/miss logic, and pipeline stall mechanisms under various load conditions.

\pagebreak
\tableofcontents
\pagebreak
\listoffigures
\pagebreak
\listoftables
\pagebreak

% --- Chapter 1: Introduction ---
\chapter{Introduction}
In modern computing, the performance gap between high-frequency processors and high-latency main memory (DRAM) necessitates sophisticated memory hierarchies. This project focuses on the hardware implementation of two critical components that bridge this gap: the Memory Management Unit (MMU) for virtual memory support and the Cache Controller for latency reduction.

The system is designed as a Physically Indexed, Physically Tagged (PIPT) cache, implying that address translation occurs prior to cache access. While this serializes the lookup path, it eliminates aliasing issues common in virtual caches, ensuring robust data integrity across processes.

\section{Motivation}
The implementation of a cache controller from scratch provides invaluable insights into micro-architectural trade-offs. By developing the RTL for tag comparison, victim selection, and write policies, we gain a cycle-accurate understanding of how hardware handles memory requests. Furthermore, the addition of a script-driven testbench allows for the rapid prototyping of complex access patterns, simulating real-world program behavior better than static test vectors.

\section{Project Objectives}
The core objective is to create a functional and modular RTL design of an MMU and a single-level cache controller. We aim to understand the intricate state machine logic required to handle various memory access scenarios, including cache hits, misses, and different write strategies.

\subsection{Memory Management Unit (MMU) Scope}
The MMU design focuses on address translation and protection. It implements a conceptual TLB model to map 32-bit virtual addresses to 32-bit physical addresses. Key functionalities include parsing the virtual address, performing a TLB lookup, and generating the corresponding physical address or signaling a miss to initiate a page table walk (simulated).

\subsection{Cache Controller Scope}
The cache controller manages an 8KB, 2-way set-associative cache. The design is parameterized to allow for configurable cache size, block size, and associativity. It supports a write-through policy with a no-write-allocate strategy for misses, utilizing a 1-bit Least Recently Used (LRU) policy for handling cache evictions.

\section{Methodology}
Our design methodology follows a rigorous RTL design flow tailored for ASIC implementation.
\begin{enumerate}
    \item \textbf{Architectural Modeling:} Defining the state elements (SRAMs, Tag Stores) and control logic (FSM) based on theoretical models.
    \item \textbf{RTL Design Entry:} Implementing the modules in Verilog-2001, ensuring synthesizability and modularity.
    \item \textbf{Functional Verification:} Developing a comprehensive testbench environment using Synopsys VCS to validate functionality against corner cases.
    \item \textbf{Debugging and Analysis:} Utilizing Synopsys Verdi to analyze waveforms, trace signal drivers, and verify FSM transitions.
\end{enumerate}

\subsection{Tools and Technologies}
The project leverages industry-standard EDA tools for verification and analysis.
\begin{itemize}
    \item \textbf{Synopsys VCS:} Used for high-performance compilation and simulation of the Verilog RTL.
    \item \textbf{Synopsys Verdi:} Employed for advanced waveform debugging and signal tracing.
    \item \textbf{Verilog-2001:} The primary hardware description language used for implementation.
\end{itemize}

% --- Chapter 2: Literature Survey ---
\chapter{Literature Survey}

\section{Foundational Concepts in Computer Architecture}
A review of foundational literature was conducted to establish the theoretical basis for our design. Textbooks such as "Computer Architecture: A Quantitative Approach" by Hennessy and Patterson and "Computer Architecture and Organization" by Smruti Sarangi provided comprehensive insights into memory hierarchies and caching principles \cite{sarangi2017computer}.

For practical implementation strategies, we analyzed the open-source Bluespec implementation of the SHAKTI processor's cache controller \cite{shakti_cache}. Additionally, educational resources from GeeksforGeeks and Branch Education were consulted to reinforce concepts regarding VIPT caches and virtual memory mechanisms \cite{gfg_cache, branch_edu_cache, tech_nikola, gfg_vipt}. This research directly informed our decisions regarding the 2-way set-associative structure and the write-through policy implementation.

\begin{table}[ht]
\centering
\caption{System Configuration Parameters}
\vspace{0.2cm}
\label{t1}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Parameter} & \textbf{Value} & \textbf{Parameter} & \textbf{Value} \\ \hline
Virtual Address Width & 32 bits & Physical Address Width & 32 bits \\ \hline
Cache Size & 8 KB & Associativity & 2-way \\ \hline
Block Size & 64 Bytes & Write Policy & Write-Through \\ \hline
Page Size & 4 KB & Replacement Policy & 1-bit LRU \\ \hline
\end{tabular}
\end{table}

% --- Chapter 3: Work Done ---
\chapter{Work Done}

\section{Project Progress}
We have successfully completed the architectural design, RTL implementation, and functional verification of the entire memory subsystem. The following sections detail the specific implementations and the mathematical foundations governing the design.

\subsection{System Architecture and Pipeline Design}
The system comprises three main blocks: the CPU interface (simulated via testbench), the MMU, and the Cache Controller. The architecture follows a strict pipeline where the CPU issues a Virtual Address (VA), the MMU translates this to a Physical Address (PA) via the TLB, and the Cache Controller utilizes the PA to index into the SRAM arrays.

A robust 7-state Finite State Machine (FSM) was designed to govern the cache controller's operation, handling states such as \texttt{S\_IDLE}, \texttt{S\_CHECK\_HIT}, \texttt{S\_READ\_MISS\_REFILL}, and \texttt{S\_WRITE\_THROUGH}.

\subsection{Memory Management Unit (MMU) Implementation}
We implemented a fully associative TLB model within the MMU. Unlike direct-mapped buffers, a fully associative design allows any Virtual Page Number (VPN) to be stored in any slot, maximizing hit rates for the small number of entries implemented.
\begin{itemize}
    \item \textbf{Lookup Logic:} The TLB compares the incoming VPN against all valid tags simultaneously in a single clock cycle.
    \item \textbf{Refill Logic:} Upon a miss, the system signals a miss condition which, in a full system, would trigger a Page Table Walk.
\end{itemize}

\section{Foundational Memory Management Formulas}
The RTL design is guided by standard addressing formulas used to locate and validate data.

\subsection{Cache Address Decomposition}
The 32-bit Physical Address is decomposed as follows, based on the 8KB size and 64B blocks:
\begin{equation}
\text{Offset} = \log_2(64) = 6 \text{ bits}
\end{equation}
\begin{equation}
\text{Index} = \log_2\left(\frac{8192}{64 \times 2}\right) = 6 \text{ bits}
\end{equation}
\begin{equation}
\text{Tag} = 32 - 6 - 6 = 20 \text{ bits}
\end{equation}

\subsection{MMU Address Decomposition}
For virtual-to-physical translation, the MMU splits the address based on the 4KB page size.
\begin{equation}
\text{Page\_Offset\_bits} = \log_2(4096) = 12 \text{ bits}
\end{equation}
\begin{equation}
\text{VPN\_bits} = 32 - 12 = 20 \text{ bits}
\end{equation}

\subsection{Performance Metrics}
The simulation environment allows us to verify the behavior that impacts Average Memory Access Time (AMAT).
\begin{equation}
\text{AMAT} = \text{Hit\_Time} + (\text{Miss\_Rate} \times \text{Miss\_Penalty})
\end{equation}
Our cycle-accurate simulation confirms a Hit Time of 1 clock cycle and a variable Miss Penalty simulated by the main memory model.

\section{Implementation Highlights and Code Analysis}
Several advanced implementation details were critical to the project's success.

\subsection{Script-Driven Verification Environment}
A unique feature of this project is the implementation of a file-based instruction reader in the testbench. Instead of hardcoding test vectors, the testbench uses Verilog file I/O system tasks (\texttt{\$fopen}, \texttt{\$fscanf}) to read a text file (`instructions.txt`) containing memory operations.

\textbf{Instruction Format:}
\begin{verbatim}
R 0x1000      // Read from 0x1000
W 0x2000 A    // Write 0xA to 0x2000
\end{verbatim}
This approach allows for the rapid creation of complex test scenarios without recompiling the Verilog code.

\subsection{Coherence and Invalidation Logic}
During the implementation of the Write-Through policy, we observed a potential data inconsistency. To resolve this, we implemented an \textbf{Invalidation Protocol}. On any Write Hit, the controller explicitly invalidates the matching cache line.

\begin{lstlisting}[language=Verilog, caption=Invalidation Logic in Verilog]
// Invalidate cache line on Write Hit
if (state == S_CHECK_HIT && is_hit && reg_is_write) begin
     if (way0_hit) valid_store[addr_index][0] <= 1'b0;
     if (way1_hit) valid_store[addr_index][1] <= 1'b0;
end
\end{lstlisting}
This forces the next read to the same address to result in a Cache Miss, triggering a fetch from main memory which retrieves the updated data, ensuring coherence.

\section{Simulation Observations}
During the verification phase, several critical behaviors were observed and corrected.

\subsection{Observation 1: Reset Logic and Verilog Standards}
Initial simulations showed that internal storage arrays (`tag\_store`, `lru\_store`) remained in an unknown state (`X`) after reset. Analysis revealed this was due to the use of Verilog-2001 syntax (`integer i=0` inside a `for` loop) with a simulator defaulting to Verilog-1995 standards. The code was refactored to declare loop variables at the module scope, resolving the initialization issue.

\subsection{Observation 2: Hit/Miss Signal Timing}
An important timing behavior was observed regarding the `hit\_miss` output signal. The testbench initially checked this signal after the controller returned to the `IDLE` state. However, by that time, the cache had already refilled the missing line, causing the logic to report a "Hit" for what was actually a "Miss" event. We updated the verification logic to capture the `hit\_miss` signal state \textit{during} the request cycle, allowing for accurate hit/miss statistics.

% --- Chapter 4: Future Work ---
\chapter{Future Work}

\section{Future Objectives}
While the RTL design and functional verification are complete, the ultimate goal of this project is to proceed through the complete ASIC design flow towards tapeout. The future work is therefore focused on the physical implementation stages.

\begin{enumerate}
    \item \textbf{Logic Synthesis:} The verified RTL will be synthesized using Synopsys Design Compiler to generate a gate-level netlist mapped to a standard cell library (e.g., 45nm or 28nm technology node). This step will provide concrete area, power, and timing estimates.
    \item \textbf{Static Timing Analysis (STA):} Comprehensive timing analysis will be performed using Synopsys PrimeTime to ensure the design meets setup and hold time constraints across various process, voltage, and temperature (PVT) corners.
    \item \textbf{Floorplanning and Placement:} We will define the physical footprint of the chip, placing memory macros (SRAMs) and standard cells to optimize wire length and congestion.
    \item \textbf{Clock Tree Synthesis (CTS):} A robust clock distribution network will be inserted to minimize clock skew and insertion delay across the chip.
    \item \textbf{Routing and Physical Verification:} The final interconnections will be routed, followed by Design Rule Checking (DRC) and Layout vs. Schematic (LVS) checks to ensure the physical layout matches the logical design and manufacturing constraints.
    \item \textbf{GDSII Generation:} The final deliverable will be the GDSII stream file, ready for foundry fabrication (tapeout).
\end{enumerate}

\pagebreak
\addcontentsline{toc}{section}{References}
\begin{thebibliography}{99}

\bibitem{sarangi2017computer}
S. R. Sarangi, \textit{Computer Architecture and Organization}. McGraw-Hill Education, 2017.

\bibitem{shakti_cache}
SHAKTI Processor Project, "SHAKTI Cache Controller Implementation in Bluespec," \url{https://gitlab.com/shaktiproject/uncore/caches}.

\bibitem{branch_edu_cache}
Branch Education, "Cache Memory and RAM Explained," \url{https://youtu.be/7J7X7aZvMXQ?si=TxehuOpF31d4Nuxu}.

\bibitem{tech_nikola}
Tech With Nikola, "But, what is Virtual Memory?", \url{https://youtu.be/A9WLYbE0p-I?si=BJN-8I-X92I3BC5-}.

\bibitem{gfg_cache}
Geeks for Geeks, "Cache Memory in Computer Organization," \url{https://www.geeksforgeeks.org/cache-memory-in-computer-organization/}.

\bibitem{gfg_vipt}
Geeks for Geeks, "Virtually Indexed Physically Tagged (VIPT) Cache," \url{https://www.geeksforgeeks.org/computer-organization-architecture/virtually-indexed-physically-tagged-vipt-cache/}.

\end{thebibliography}

\end{document}